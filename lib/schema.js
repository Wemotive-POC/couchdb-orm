class Schema {
    constructor(schema, options={}) {
        this.schema = schema;
        this.required = Object.keys(schema).filter(key => schema[key].required);
        this.indexes = options.indexes || [];
        this.indexes = this.indexes.map(index => {
            if (Array.isArray(index))
                return {
                    index: {
                        fields: index,
                    },
                    name: "orm_autogenerated_index_" + index.sort().join("__")
                };
            return index;
        });
    }

    isValidDoc(document, logError=false) {
        try {
            eval(this.generateValidator())(document);
            return true;
        } catch (_) {
            if (logError)
                console.log(_);
            return false;
        }
    }

    generateValidator(nested=false, name="doc") {
        const lineSep = "\n            ";
        let string = `
        (doc, name=${JSON.stringify(name)}) => {
            if (doc._deleted)
                return;
            function requireField(field) {
                const message = name + " must have a " + field;
                if (doc[field] === undefined) throw({forbidden : message});
            }
        `;
        if (!nested)
            string += `
            // Standard boilerplate

            function typeCheck(value) {
              const return_value = Object.prototype.toString.call(value);
              const type = return_value.substring(
                       return_value.indexOf(" ") + 1,
                       return_value.indexOf("]"));
              return type.toLowerCase();
            }

            // First let's check if valid keys are available
            `;
        if (this.required.length)
            string += this.required
                .map(i => "requireField(" + JSON.stringify(i) + ");")
                .reduce((i,j) => i + lineSep + j);

        string += `

            // Next let's check if the types are correct

        `;

        const typeChecked = Object.keys(this.schema)
            .filter(key => this.schema[key].type);

        const nonObj = typeChecked.filter(key => typeof this.schema[key].type !== "object");
        nonObj.forEach(
            key => {
                let type = null;
                switch (this.schema[key].type) {
                case String:
                    type = "string";
                    break;
                case Array:
                    type = "array";
                    break;
                case Number:
                    type = "number";
                    break;
                case Date:
                    type = "date";
                    break;
                case Boolean:
                    type = "boolean";
                    break;
                default:
                    throw({ error: `Invalid type ${this.schema[key].type} for ${key}` });
                }
                string += `
                if (doc[${JSON.stringify(key)}] !== undefined && typeCheck(doc[${JSON.stringify(key)}]) !== "${type}")
                    throw({ forbidden: "Invalid type for " + name + "." + ${JSON.stringify(key)} });
                `;
            }
        );

        // Let's now test the validation function for all keys that have them
        Object.keys(this.schema)
            .filter(key => this.schema[key].validate)
            .forEach(key => {
                const func = this.schema[key].validate.toString();
                string += `
                    (${func})(doc[${JSON.stringify(key)}]);
                `;
            });
        // We want to nest the tests for object types
        const obj = typeChecked.filter(key => typeof this.schema[key].type === "object");
        obj.forEach(
            key => {
                const validator = (new Schema(this.schema[key].type))
                    .generateValidator(true);
                string += `
                doc[${JSON.stringify(key)}] !== undefined && (
                    ${validator})(doc[${JSON.stringify(key)}], name + "." + ${JSON.stringify(key)})`;
            }
        );
        string += `
        }`;

        return string;
    }
}

module.exports = (...args) => { return new Schema(...args); };
